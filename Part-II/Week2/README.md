# Part-II Week2

标签： Coursera

---

## Question I
第一题要求求解在聚类问题中给定K时最大的分类间隔，即：
给定n个点，并定义点之间的相似度度量`d(p,q)`。当聚类数目为K时，求解使得不同类别的点的距离最大的聚类结果。
更加详细的问题描述和解题方法可以参见 [max spacing in k-clustering](https://www.cs.umd.edu/class/summer2009/cmsc451/lectures/class05-clustering_compressing-6.pdf)

这个问题可以使用贪心解答。每次选取距离最近的点对，将它们聚为相同的类。直到聚类数量降到K为止。

更进一步，这个问题可以看做是在图中构建最小生成树MST。只不过最小生成树要求最终所有的点都聚为同一类（即K=1的特殊情况），而这里只需要聚类数目为K时停机即可。

## Question II
问题2和问题1的背景相同，只不过数据量大了。不能通过列举所有的点两两之间的边然后排序了（20万个点，两两之间的Edge即为O(n^2)，即4x10^10量级，仅仅存储这些边的权重就过于庞大）。
这个问题我只是找到了一种naive的解决办法，离最优差的远，只不过是可以跑出结果，大约要耗时10+分钟。建立汉明码和顶点的 `map<HamingCode, vector<int>>`。
由于本题要求max spacing 不能小于3，所以只需要将weight为0,1,2的边对应的顶点进行聚类即可。也就是相应的汉明码相同，只变化一位，只变化两位。对于所有的汉明码，枚举所有的变位结果，再将其聚类即可。由于map的查询速度很快(O(logn))，所以可以较快地得到答案。在实际编码过程中，可以预先生成24*24的mask，与汉明码异或，就得到了修改某一个或几个特定位的新的码。




