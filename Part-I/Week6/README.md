# 中位数

标签： Coursera

---
## 题目描述
设`Xt = [x1, x2, ... ,xt]` 是整型数的stream，令`mt = median(Xt)` ，求$$S = \sum_{t=0}^{T}m_t$$。

## 两个heap解决问题
要解决上面的问题，直观上我们只要知道每个时刻的中位数再加起来就行了。所以问题的关键在于如何快速求得t时刻的中位数。
如果每来一个数，我们都重新排序求解的话，时间复杂度是O(n^2log(n))，不是一个很好地解决方案。
实际上，我们通过维护两个heap，一个大根堆，一个小根堆即可，并保持两个堆之间的元素个数最多相差1.其中，大根堆中的元素都是stream的前一半元素，小根堆里面的元素都是stream的后一半元素。这样，中位数就肯定是大根堆的顶点。
令每次迭代完成后，大根堆的元素个数与小根堆要么相等，要么多1.
```
for each new num:
    if num < root of max-heap:
         max-heap.add(num)
    else
        min-heap.add(num)       
    blance(min-heap, max-heap)  // 保持两者元素个数相等或相差1
```
在blance之前，大根堆与小根堆的元素个数可能有以下几种情况：

- 两者原来个数相同，新元素进入大根堆，这时不用调整
- 两者原来个数相同，新元素进入小根堆，这时需要将小根堆的顶点元素删除，并插入到大根堆中。
- 原来大根堆比小根堆多1，新元素进入小根堆，不用调整
- 原来大根堆比小根堆多1，新元素进入大根堆，需要将大根堆的顶点元素删除，并插入小根堆。

按照上述四种情况，相应调整，就能够保持循环不变式正确。自然也就能够得到正确的中位数。





